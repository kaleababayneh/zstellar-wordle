{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"814801766663522550","abi":{"parameters":[{"name":"commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_path","type":{"kind":"array","length":14,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_indices","type":{"kind":"array","length":14,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"first_letter","type":{"kind":"field"},"visibility":"private"},{"name":"second_letter","type":{"kind":"field"},"visibility":"private"},{"name":"third_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fourth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fifth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"pZfRbqswDIbfhetexHEcJ3uVo6OJdWyqhGjF2klH0979hPY3XS9AE7n63YI/+TdxAl/Na/dyeX8+DG/Hj+bpz1fzMh76/vD+3B/37flwHMq/X9+7xn4+n8euK381P66XrFM7dsO5eRoufb9rPtv+cr3p49QOVz23Y7nqdk03vBYtwLdD303R9+6e7ZZToxCSNfKcLo/5tJzP4pEfKN7z9SHfL+d7nzIAnp1fIvAygShaCURJthDYWQ3EPi0RZJmQgwCQZUs+OT97cFHqKlDZ8hyUoj0HZbdEyCseVNk8aF58kuQq2/hLwHIX1gC/fBBrbcj3xZT9YhtWalC1J5EoLI3kqgdOsweJtYToqwmplqDb+pDdvDG4XEsgqSV4quzDRgKxzgSRWkKsdrGNUPaXmZBrV3U9wftNa5LvLjjXEzat6kC2S1LwmwjC8x4nurg/MFe+N3Cof3GQ+jeHUH1sTuNTeW5OK6/q3FwD/PLYW7VRfe5RlHldxvS4qv6WX+3+MD68PjcUymm5a0huEqeRKKrQBM039W5arkWpOCmvtN5DGVpoodTnBRqhCk3QfFN2UIJ6KEPBY7nxOUIVCh6DF8AL4AXwAuoLAQpeQH0B9QXwAngCnsCvwK+AJ6hP4FfAE/AEPMm3+6ODghdRX4TfCF4EL4IX4TcmKHiK+hR+FTwFT8FT+FX0T8FT1Kfwm8BL4CXwEvwm9C+Bl1Bfgt8EXgIvg5fhN6N/GbyM+jL8ZvAyeBm8DL/knAVkAUosB4sFwQKxIFqglpUsMDKh1PKWYoGRychkZBLLihYYmZLdgx6QN7I3sjeyzQ35YIGRbXTIZodseMimh2x8iK0b7C0wso0QsXWDjcxGtjGi6xxN28ZnOx7al77DJ/bbZdj/+OI+/zvZFfsmP43Hffd6Gbtpe7leKxvOfw==","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\n\nfn main(\n    // -- Public inputs --\n    // Poseidon2 commitment to the word: hash(salt, l1, l2, l3, l4, l5)\n    commitment_hash: pub Field,\n    // Poseidon2 Merkle root of the word list\n    merkle_root: pub Field,\n\n    // -- Private inputs --\n    // Merkle proof (14 levels for ~12,653 words, 2^14 = 16,384 capacity)\n    merkle_path: [Field; 14],\n    merkle_indices: [u8; 14],\n    // Word letters \n    first_letter: Field,\n    second_letter: Field,\n    third_letter: Field,\n    fourth_letter: Field,\n    fifth_letter: Field,\n    // Salt \n    salt: Field,\n) {\n    // Verify commitment\n    let computed_commitment = Poseidon2::hash(\n        [salt, first_letter, second_letter, third_letter, fourth_letter, fifth_letter], 6\n    );\n    assert(computed_commitment == commitment_hash);\n\n    // 2. Compute the leaf: encode word as a single field element\n    //    leaf = l1*256^4 + l2*256^3 + l3*256^2 + l4*256 + l5\n    //    This matches the encoding used to build the Poseidon2 Merkle tree.\n    let leaf = first_letter * 256 * 256 * 256 * 256\n             + second_letter * 256 * 256 * 256\n             + third_letter * 256 * 256\n             + fourth_letter * 256\n             + fifth_letter;\n\n    // 3. Walk the Merkle path from leaf to root using Poseidon2\n    let mut current_hash = leaf;\n    for i in 0..14 {\n        let (left, right) = if merkle_indices[i] == 1 {\n            (merkle_path[i], current_hash)\n        } else {\n            (current_hash, merkle_path[i])\n        };\n        current_hash = Poseidon2::hash([left, right], 2);\n    }\n\n    // Verify the computed root matches the public Merkle root\n    assert(current_hash == merkle_root);\n}\n\n\n#[test]\nfn test_word_commit() {\n    // Word: \"apple\" -> a=97, p=112, p=112, l=108, e=101\n    let salt = Field::from(0);\n    let first_letter = Field::from(97);\n    let second_letter = Field::from(112);\n    let third_letter = Field::from(112);\n    let fourth_letter = Field::from(108);\n    let fifth_letter = Field::from(101);\n\n    // Compute commitment\n    let commitment_hash = Poseidon2::hash(\n        [salt, first_letter, second_letter, third_letter, fourth_letter, fifth_letter], 6\n    );\n\n    // Compute leaf\n    let leaf = first_letter * 256 * 256 * 256 * 256\n             + second_letter * 256 * 256 * 256\n             + third_letter * 256 * 256\n             + fourth_letter * 256\n             + fifth_letter;\n\n    let zero = Field::from(0);\n    let merkle_path = [zero; 14];\n    let merkle_indices = [0; 14];\n\n    // Compute expected root by hashing up 14 levels\n    let mut expected_root = leaf;\n    for _i in 0..14 {\n        expected_root = Poseidon2::hash([expected_root, zero], 2);\n    }\n\n    main(\n        commitment_hash,\n        expected_root,\n        merkle_path,\n        merkle_indices,\n        first_letter,\n        second_letter,\n        third_letter,\n        fourth_letter,\n        fifth_letter,\n        salt,\n    );\n}","path":"/Users/kaleab/Documents/zstellar-wordle/circuit-word-commit/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/kaleab/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}