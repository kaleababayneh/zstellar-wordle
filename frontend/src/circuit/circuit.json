{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"10149638093663211960","abi":{"parameters":[{"name":"commitment_hashes","type":{"kind":"field"},"visibility":"public"},{"name":"first_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"second_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"third_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"fourth_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"fifth_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"calculated_result","type":{"kind":"array","length":5,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"first_letter","type":{"kind":"field"},"visibility":"private"},{"name":"second_letter","type":{"kind":"field"},"visibility":"private"},{"name":"third_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fourth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fifth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"pZfdbuIwFITfJddcePzvvspqVVGarpAiQCmstKp493XITNJeJKrSG86BxN+xj2ds8dG8ti+3P8/H09v5vXn69dG89MeuO/557s6H/fV4PtVfP+67Rl+fr33b1p+aT8/rqMu+b0/X5ul067pd83ff3R4vvV/2p0e87vv61Oya9vRaYwW+Hbt2yO67ebRZHgqfHUcjZEyA8JWAZYILlgCPOI9PX8bb5fHW5kKAdcYuEdzKGhA1BSCHLQRnNAc4m5cIYZlQfCCghC3jYey0BhPDz2aQwpZ9SIjah+TMEqGsrCGlSUupLO4kzA/b+E3AchfWAN/ciLU2lFlMxS62YdWUs6BXTLlGyDnOc/BbCMXNqwhbCNakJEEBYQvBWgmqZnkTocyHCzatwmXthfXLq7BYawSmSRj76Yy833/XL/vDsf9yLTSheaqdi4/PNBxJuyaPoYwBhhGDQmq0NdYNh2P0jIExDpKoMTFmxjJGaxjBaBkdo2cMjORZ8ix5ljxHniPPkefIc+Q58hx5jjxHniPPk+fJ8+R58jx5nrxgxnUHMLI/gf0JfD/ofdYPrB9YP7B+ZP3I+pH1I+tH8iJ5kbxIXiQvkpfIS+Ql8hJ5ibxEXiIvkZfIS+Rl8jJ5mbxMXs7junMZY2F/CvtT+H7h+4X1C+sX1i+sX1i/sD6MUQIlVolT4pUEJZKlkS6NhGlEhsgQGSJDZIgMkSfBT4qfJC/NQ6KHVI+HrAe7PHT9SLKSIodplLQNiRtSNyRvSN+QwCGFQxKHNA6JHFI5JHNI55DQIaXXq0KJyF5kL3IQOYgcRA4iyxKQJyBTQK6AbAH5AlEHTZxOGvUwqocSP6R+SP6Q/iEDQA6ALAB5AGk6xDQf2QDyAWQEyAmQFSAvIIucRc4i5+l8FDmLXEQuIss0kGsg20C+gYwDOccOvhguCzv4Yky8kqAkDsl9uFH64/6la/ln4e12Onz673D9d9ET/bu49OdD+3rr2+FCeTyrV8x/","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\n\nfn main(\n    // hash of all letters with salt\n    commitment_hashes: pub Field,\n    // public inputs\n    first_letter_guess: pub Field,\n    second_letter_guess: pub Field,\n    third_letter_guess: pub Field,\n    fourth_letter_guess: pub Field,\n    fifth_letter_guess: pub Field,\n    // calculated final result\n    calculated_result: pub [u8; 5],\n    // private inputs\n    first_letter: Field,\n    second_letter: Field,\n    third_letter: Field,\n    fourth_letter: Field,\n    fifth_letter: Field,\n    salt: Field,\n    )\n     {\n\n    // let first_letter_commitment = Poseidon2::hash([ salt, first_letter], 2);\n    // assert(first_letter_commitment == first_letter_commitment_hash);\n    // let second_letter_commitment = Poseidon2::hash([salt, second_letter], 2);\n    // assert(second_letter_commitment == second_letter_commitment_hash);\n    // let third_letter_commitment = Poseidon2::hash([salt, third_letter], 2);\n    // assert(third_letter_commitment == third_letter_commitment_hash);\n    // let fourth_letter_commitment = Poseidon2::hash([salt, fourth_letter], 2);\n    // assert(fourth_letter_commitment == fourth_letter_commitment_hash);\n    // let fifth_letter_commitment = Poseidon2::hash([salt, fifth_letter], 2);\n    // assert(fifth_letter_commitment == fifth_letter_commitment_hash);\n    // The above code is commented out to avoid redundancy, as the commitment verification can be done outside the circuit.\n\n    assert(commitment_hashes == Poseidon2::hash([salt, first_letter, second_letter, third_letter, fourth_letter, fifth_letter], 6));\n\n\n\n    let mut correct_letters = [first_letter, second_letter, third_letter, fourth_letter, fifth_letter];\n    let guess_letters = [first_letter_guess, second_letter_guess, third_letter_guess, fourth_letter_guess, fifth_letter_guess];\n    let mut result_array = [0; 5];\n\n    for i in 0..5 {\n        if guess_letters[i] == correct_letters[i] {\n            result_array[i] = 2; // Correct letter\n        } else {\n            let mut found = false;\n            for j in 0..5 {\n                if correct_letters[j] == guess_letters[i] {\n                    found = true;\n                }\n            }\n            if found {\n                result_array[i] = 1; // Wrong position\n            } else {\n                result_array[i] = 0; // Incorrect letter\n            }\n        }\n    }\n\n    assert(calculated_result == result_array);\n}\n\n\n\n\n#[test]\nfn test_main() {\n    println(\"test\");\n    let salt = Field::from(0);\n\n    let first_letter: Field = Field::from(97);  // a\n    let second_letter: Field = Field::from(112); // p\n    let third_letter: Field = Field::from(112);  // p\n    let fourth_letter: Field = Field::from(108); // l\n    let fifth_letter: Field = Field::from(101);  // e\n\n    // Single Poseidon2 hash of all letters with salt\n    let commitment_hashes: Field = Poseidon2::hash(\n        [salt, first_letter, second_letter, third_letter, fourth_letter, fifth_letter], 6,\n    );\n\n    let first_letter_guess: Field = Field::from(97);  // a\n    let second_letter_guess: Field = Field::from(112); // p\n    let third_letter_guess: Field = Field::from(112);  // p\n    let fourth_letter_guess: Field = Field::from(97);  // a\n    let fifth_letter_guess: Field = Field::from(111);  // o\n\n    let result: [u8; 5] = [2, 2, 2, 1, 0];\n\n    main(\n        commitment_hashes,\n        first_letter_guess,\n        second_letter_guess,\n        third_letter_guess,\n        fourth_letter_guess,\n        fifth_letter_guess,\n        result,\n        first_letter,\n        second_letter,\n        third_letter,\n        fourth_letter,\n        fifth_letter,\n        salt,\n    );\n}","path":"/Users/kaleab/Documents/rs-soroban-ultrahonk/circuit/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/kaleab/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}